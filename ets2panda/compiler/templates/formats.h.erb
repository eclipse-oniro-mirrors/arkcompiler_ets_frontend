% def get_format_name(mnemonic)
%   return "#{mnemonic.gsub('.', '_').upcase}" + "_FORMATS"
% end
% def get_format_item_name(mnemonic, index)
%   return "#{mnemonic.gsub('.', '_').upcase}" + "_FORMAT_ITEMS_" + index.to_s
% end
% def get_reg_limit_name(mnemonic)
%   return "#{mnemonic.gsub('.', '_').upcase}" + "_REG_LIMIT"
% end
% def get_operand_reg_kind_name(mnemonic)
%   return "#{mnemonic.gsub('.', '_').upcase}" + "_OPERAND_REG_KIND"
% end
/**
 * Copyright (c) 2021-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Autogenerated file -- DO NOT EDIT!

#ifndef ES2PANDA_COMPILER_GEN_FORMATS_H
#define ES2PANDA_COMPILER_GEN_FORMATS_H

#include "ir/irnode.h"

namespace ark::es2panda::compiler {
% def get_operand_kind(op, insn)
%   if op.reg?
%     if op.src? and op.dst?
%       return "OperandKind::SRC_DST_VREG"
%     elsif op.src?
%       return "OperandKind::SRC_VREG"
%     elsif op.dst?
%       return "OperandKind::DST_VREG"
%     end
%     return nil
%   elsif op.imm?
%     is_jump = insn.properties.include? 'jump'
%     return is_jump ? "OperandKind::LABEL" : "OperandKind::IMM"
%  elsif op.id?
%    is_string_id = insn.properties.include? 'string_id'
%    return is_string_id ? "OperandKind::STRING_ID" : "OperandKind::ID"
%  elsif op.prof?
%    return "OperandKind::IMM"
%  else
%    return nil
%  end
% end
%
% def get_operand_reg_kind(op)
%   if op.reg?
%     if op.src? and op.dst?
%       return "OperandKind::SRC_DST_VREG"
%     elsif op.src?
%       return "OperandKind::SRC_VREG"
%     elsif op.dst?
%       return "OperandKind::DST_VREG"
%     end
%   else
%     return nil
%   end
% end
%
% def get_reg_limit_for_format(fmt)
%   limit_arr = fmt.operands.select {|op| op.reg?}.map {|op| op.width}
%   return limit_arr.length == 0 ? 0 : limit_arr.max
% end
%
% def make_operand_reg_kind(fmt)
%   operand_reg_kind = fmt.operands.select {|op| op.reg?}.map{|op| "#{get_operand_reg_kind(op)}"}
%   return operand_reg_kind
% end
%
% def make_format(fmt, insn)
%   operands = fmt.operands.map {|op| "{#{get_operand_kind(op, insn)}, #{op.width}}"}
%   return operands
% end
%
constexpr std::array<OperandKind, 0> LABEL_OPERAND_REG_KIND = { };
%
% Panda::instructions.group_by(&:mnemonic).each do |mnemonic, group|
% insn = group.first
% formats = group.map {|i| make_format(i,insn) }
% reg_limit_widths = group.map {|i| get_reg_limit_for_format(i)}
% reg_limit = reg_limit_widths.length == 0 ? 0 : 1 << reg_limit_widths.max
% operand_reg_kind_arr = group.map {|i| make_operand_reg_kind(i) }
% operand_reg_kind = operand_reg_kind_arr.length == 0 ? [] : operand_reg_kind_arr[0]
% empty = false
% formats.each.with_index do |fmt, index|
%   if fmt.length != 0
constexpr std::array<const FormatItem, <%= fmt.length %>> <%= get_format_item_name(mnemonic, index) %> = {{
  <%= fmt.join(", ") %>
}};
%   else
%     empty = true
%   end
% end
%
%   if empty
constexpr std::array<const Format, 0> <%= get_format_name(mnemonic) %>  = {{}};
%   else
constexpr std::array<const Format, <%= formats.length %>> <%= get_format_name(mnemonic) %> = {{
% format_items = (0..(formats.length - 1)).map {|index| "{" + get_format_item_name(mnemonic, index) + ".data(), " +  get_format_item_name(mnemonic, index) + ".size()}" }
  <%= format_items.join(", ") %>
%
}};
%   end
constexpr uint32_t <%= get_reg_limit_name(mnemonic) %> = <%= reg_limit %>;
constexpr std::array<OperandKind, <%= operand_reg_kind.length %>> <%= get_operand_reg_kind_name(mnemonic) %> = { <%= operand_reg_kind.length == 0 ? "" : operand_reg_kind.join(", ") %> };
% end
}  // namespace ark::es2panda::compiler

#endif
